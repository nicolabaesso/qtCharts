% Don't change anything in this top section!

\documentclass[10pt]{article} 

\usepackage{graphicx,gb4e,qtree,latexsym,tree-dvips,times,tipa,stmaryrd}
\usepackage[normalem]{ulem}
\usepackage[]{natbib}
\usepackage{hyperref}

\newcommand{\denplain}[1]{$\llbracket$#1$\rrbracket$} 

\newcommand{\denote}[2][]{$\llbracket$#2$\rrbracket$^{{\ensuremath #1}}} 

\newcommand{\ab}[1]{$\langle$#1$\rangle$}

\newcommand{\refp}[1]{(\protect\ref{#1})}

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\setlength{\parindent}{.5 in}
\setlength{\textwidth}{6.5 in}
\setlength{\oddsidemargin}{0 in}
\setlength{\textheight}{9.0 in}
\setlength{\topmargin}{-0.7 in}


\pagestyle{empty}

\author{Nicola Baesso}
\title{Relazione Progetto}

\begin{document}
	\setlength{\baselineskip}{13 pt}
	
	\maketitle
	
	% Here is the part of the .tex file that you have to worry about!
	
	29/11/2021 (2 ore): creazione progetto tramite l'utilizzo di video d tutor
	
	04/12/2021 (1 ora): creazione UML classi
	
	06/12/2021 (1 ora): proseguo UML
	
	18/12/2021 (1 ora): inizio stesura codice, header e classe "data". Next step: "dataHandler"
	
	20/12/2021 (1 ora): continuo stesura codice. Next step gestione file XML
	
	27/12/2021 (3 ore): stesura codice GUI, classe Chart per la visualizzazione, modifica di datahandler. Next step: implementazione della gestione file XML in DataHandler
	
	29/12/2021 (2 ore): continuazione di codice per fileHandler, creazione header per i grafici.
     
    30/12/2021 (3 ore): creazione della classe model per il collegamento di model e view, bug fixes, creazione di exception.
    
    03/01/2022 (3 ore): modifica uml, metodo di lettura dati da file. Inizio classe Controller
    
    04/01/2022 (6 ore): continuo UML, continuo controller.
    
    05/01/2022 (3 ore): continuo controller, classi Chart.
    
    07/01/2022 (6 ore): continuo view e charts
    
    10/01/2022 (2 ore): continuo view e controller
    
    11/01/2022 (1 ora): modifica scrittura di nuovo file (salvataggio e titolo chart)
    
    14/01/2022 (2 ore): modifica window. Da proseguire
    
    15/01/2022 (2 ore): proseguo modifica window. Da fare: connettere con controller (e model di conseguenza)
    
    16/01/2022 (1 ora): cambio di layout ad apertura di un nuovo file. Da fare: vedi 15/01/2022 e implementare anche nella creazone di un file
    
    17/01/2022 (3 ore): step su 15/01/2022, da finire. Risolto bug su BarChart
    
    18/01/2022 (4 ore): miglioramenti, da completare modifiche file. UPDATE: risolto modifiche file. Da fare: tema scuro, possibilità di modificare il nome del grafico, test...
    
    23/01/2022 (1 ora): modifica nome grafico e aggiunta icona applicazione. Da fare: tema scuro, auto-update, test...
    
    25/01/2022 (3 ore): sistemazione codice.
    
    27/01/2022 (2 ore): modifica UML
    
    \newpage
    \hypersetup{hidelinks}
    \tableofcontents
    \newpage
    \section{Introduzione}
     Questo progetto riguarda un applicativo C++/Qt per la visione di dati sotto forma di grafici. L'applicazione permette una gestione ottimale dei dati, senza rinunciare alla comodità di un' interfaccia grafica.
    \subsection{Strumenti di sviluppo utilizzati}
    Il progetto è stato scritto utilizzando l'IDE QtCreator alla versione 4.5.2, ed è stato utilizzata la versione 5.9.5 del framework Qt. 
    La seguente relazione è stata create tramite LaTex utilizzando TexStudio.
    Il codice è stato scritto e testato in Windows 10 (versione 21H1) e in Debian 11 Bullseye.
    Inoltre, il codice è stato versionato tramite Git ed è anche disponibile (sotto il nome di QtCharts) su \href{https://github.com/nicolabaesso/qtCharts}{GitHub}.
    \subsection{Compilazione ed esecuzione in sistemi Linux}
    Per la compilazione "manuale" di questo progetto, sono necessari i seguenti kit:\\
    -qt5-default (Qt 5.9.5)\\
    -libqt5charts5-dev (QtCharts)
    \\
    \\
    Inoltre, è fondamentale utilizzare il file Progetto.pro, fornito assieme a tutti i sorgenti necessari alla compilazione.\\
    \\
    Dopo essersi posizionati all'interno della cartella contenente il file con estensione .pro (e di conseguenza tutti i sorgenti), si esegui da terminale la seguente sequenza di comandi, esattamente come segue:\\
    -qmake Progetto.pro\\
    -make
    \\
    Alla fine verrà generato un file chiamato Progetto, lo si può eseguire scrivendo ./Progetto\\\\
    L'utilizzo di un file .pro differente (tra cui quello generato da qmake -project) o il mancato utilizzo dei kit riportati non assicura la corretta compilazione del programma.
    \section{Funzionamento dell'applicazione}
    \subsection{Avvio e Interfaccia Grafica}
    All'avvio, l'applicazione genera un file di esempio, contenente 5 valori, al fine di mostrare sin dal principio le funzionalità presenti, come si evince dalla figura 1.
     \begin{figure}[h!]
     	\centering
     	\includegraphics[width=0.6\linewidth]{startProgetto}
     	\caption{Schermata all'avvio}
     	\label{fig:startprogetto}
     \end{figure}
 	\\
    L'interfaccia può essere suddivisa in 3 aree principali:\\
    -la toolbar, con i tasti necessari alla creazione di un nuovo file e al salvataggio di un file, nonchè a cambiare la tipologia di grafico visualizzato e al titolo dello stesso.\\
    -la sezione "dati", che contiene i tasti per l'aggiunta di un nuovo dato, il salvataggio dei dati visibili e l'eliminazione di un determinato dato, oltre ai dati stessi con la possibilità di modifica.\\
    -la sezione "grafici", che contiene la visualizzazione dei dati sotto forma del grafico scelto, costantemente aggiornato ad ogni modifica dei dati.\\\\
    Di seguito s'illustrano le principali funzionalità dell'applicazione.
    \subsubsection{Creare un nuovo file}
    Tramite il pulsante "Nuovo file" o andando su File->Nuovo, si potrà creare un nuovo file. Verrà prima chiesto un titolo, successivamente visualizzato come titolo del grafico, poi verrà chiesto con che nome salvare il file sul quale verranno successivamente effettuate le modifiche. alla fine si avrà un file vuoto, con solo il titolo impostato.
    \subsubsection{Apertura di un file}
    \subsubsection{Salvataggio del file e salvataggio in un nuovo file}
    \subsubsection{Cambiare il titolo}
    \subsubsection{Visualizzare un grafico a punti (diagramma cartesiano)}
    \subsubsection{Visualizzare un grafico a barre (istogramma)}
    \subsubsection{Visualizzare un grafico a torta (areogramma a torta)}
    \subsubsection{Uscire dall'applicazione}
    \section{Tempistiche(Ore di lavoro)}
    \section{Caratteristiche tecniche}
    \subsection{URL e classi coinvolte}
    
    Al fine di evitare l'utilizzo di codice non estensibile, si è optato per l'utilizzo del modello MCV, che utilizza tre elementi (Model, View e Controller) per una migliore gestione degli eventi. Inoltre, come spiegato in maniera dettagliata successivamente, ogni classe presente nell'applicativo ha un ruolo ben preciso nella funzionalità.
    
    \begin{figure}[h!]
    	\centering
    	\includegraphics[width=0.7\linewidth]{UML\string_Classi}
    	\caption{UML del progetto}
    	\label{fig:umlclassi}
    \end{figure}

    \subsubsection{Classe Data}
    La classe Data rappresenta un singolo dato letto da file, o generato automaticamente all' avvio (si veda la sezione "Avvio e schermata iniziale" per maggiori dettagli).
    Tale classe è composta da una stringa, che rappresenta una breve descrizione del dato, e un valore numerico di tipo double, che rappresenta il valore del dato. Sebbene per molte circostanze un valore di tipo double sia eccessivo, si è ritenuto adatto a rappresentare la maggior parte dei dati possibili.
    \subsubsection{Classe DataHandler}
    La classe DataHandler rappresenta i dati presenti nel file letto per ultimo. Inoltre si occupa anche della modifica e della cancellazione dei dati stessi.
    La classe è composta da una stringa, che rappresenta il titolo descrittivo dei dati, nonchè la stringa che verrà visualizzata come titolo del grafico, e una struttura dati, più precisamente un vector, contente elementi di tipo Data, che rappresenta i dati letti inizialmente dal file.
    Si è optato per l'utilizzo della classe Vector, e non per altre strutture dati, magari semplici come un array, poichè le funzioni offerte da suddetta classe aiutano a gestire meglio i dati.
    \subsubsection{Classe FileHandler}
    La classe FileHandler ha lo scopo di lettura vera e propria dei dati dal file, nonchè del salvataggio di essi nello stesso o in un nuovo file. Contiene un campo QString, che rappresenta il nome del file, e un DataHandler che rappresenta i dati letti o da salvare nel file.
    \subsubsection{Classe Model}
    La classe Model è la classe che gestisce ogni singolo aspetto del modello. Essa contiene un campo FileHandler, che rappresenta  il file in lettura/scrittura.
    \subsubsection{Classe Controller}
    La classe Controller funge da tramite tra model e view. In particolare, gestisce gli eventi evocati nella view tramite interfaccia grafica, e li collega agli eventi nel model. I suoi unici campi sono di tipo Model* e Window*, ovvero puntatori a, rispettivamente, modello e view. Inoltre, ha principalmente slot invocati dai signal che emette la classe Window.
    \subsubsection{Classe Window}
    La classe Window si occupa di ogni particolare relativo all'interfaccia grafica. In altre parole, Si occupa della visualizzazione dei dati e dei grafici, nonchè alla creazione e visualizzazione dei vari menù e finestre. Contiene svariati campi, tra cui di tipo QPushButton*, QMenu*,QDialog*...\\Inoltre, ha un campo di tipo Controller* per associare ogni elemento interagibile ad un determinato segnale.
    \subsubsection{Classe Chart}
    La classe Chart rappresenta un grafico generico, e contiene un unico campo DataHandler per i dati necessari alla creazione dello stesso. Essendo un generico grafico, necessità di un'ulteriore implementazione, fornita da altre 3 classi, nonchè sottoclassi di Chart (si veda Gerarchie di Tipi per maggiori dettagli).
    Le sue relative sottoclassi utilizzano il modulo QtCharts per rappresentare graficamente i dati.
    \subsubsection{Classe BarChart}
    La classe BarChart rappresenta un semplice istogramma. Sottoclasse di Chart, ne eredita i dati per la visualizzazione grafica degli stessi, e ha un ulteriore campo int che indica il numero di set di barre da visualizzare.
    \subsubsection{Classe LineChart}
    La classe LineChart rappresenta un diagramma cartesiano.Anch'essa sottoclasse di Chart, ne eredita i dati per la visualizzazione grafica degli stessi, e ha un ulteriore campo int che indica il numero di punti da disegnare nel grafico. Inoltre, è l'unico grafico a non usare una leggenda.
    \subsubsection{Classe PieChart}
    La classe PieChart rappresenta un areogramma a torta, o più semplicemente un grafico a torta. Essendo anche questa classe sottoclasse di Chart, ne eredita i dati per la visualizzazione grafica degli stessi, e ha un ulteriore campo int che indica il numero di fette da creare per visualizzare il grafico.
    \subsection{Gerarchie di tipi e chiamate polimorfe}
    Come si evince dall'UML, nel progetto c'è la seguente gerarchia di tipo:\\
    -Chart\\
    -BarChart, derivata di Chart\\
    -LineChart, derivata di Chart\\
    -PieChart, derivata di Chart\\\\
    Il motivo è semplice: i grafici visualizzano gli stessi dati, ma in modo diverso l'un dall'altro, quindi è necessario utilizzare un elemento in comune e permettere alle sottoclassi di ricavarsi i dati necessari per la corretta visualizzazione dei dati.
    \\
    \\
    Sempre per lo stesso motivo, il metodo Window::createChart() utilizza un cast ad una delle tre sottoclassi dell'elemento di tipo Chart*, per rendere visibile all'utente finale la rappresentazione grafica dei dati.
    \subsection{Formato di file usato per I/O di file}
    Per questo progetto si è scelto di utilizzare il formato XML per la memorizzazione dei dati in file. Sebbene sia un formato "vecchio", permette una gestione più ordinata delle informazioni , inoltre è facilmente comprensibile anche all'utente.
    Per questo motivo, i file letti devono obbligatoriamente avere la formattazione presente nel file generato dall'applicativo, e da ogni file creato con esso. 
    \begin{figure}[h!]
    	\centering
    	\includegraphics[width=0.7\linewidth]{strutturaXML}
    	\caption{Struttura del file di esempio generato}
    	\label{fig:strutturaxml}
    \end{figure}
    \subsection{Conclusioni}
    
	% That's it!
	
\end{document}